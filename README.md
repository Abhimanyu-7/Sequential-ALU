# 🧮 Sequential ALU 

A **synthesizable**, clocked Arithmetic Logic Unit (ALU) written in Verilog HDL with support for core arithmetic, logic, shift, and comparison operations. This ALU is **parameterized** for width and includes **status flags** such as Carry, Zero, Negative, and Overflow. It is designed for easy integration into processor datapaths, RTL testbenches, or SoC modules.

## 📚 Table of Contents

- [🛠️ Architecture](#-architecture)
- [🧰 Project Structure](#-project-structure)
- [🔧 RTL Design](#-rtl-design)
- [🧪 Simulation](#-simulation-using-icarus-verilog--gtkwave)
- [⚙️ Synthesis using Yosys](#️-synthesis-using-yosys)
- [🏁 Gate-Level Simulation (GLS)](#-gate-level-simulation-gls)
- [📐 Area Estimation](#-area-estimation)
- [📷 Netlist Visualization (DOT)](#-netlist-visualization-dot)
- [🧠 Testbench and Verification Strategy](#-testbench-and-verification-strategy)
- [📎 References and Resources](#-references-and-resources)
- [✍️ Author](#️-author)
- [📬 Contact](#-contact)


## 🛠️ Architecture

The ALU is divided into two key blocks:

1. **Combinational Logic Block**  
   Computes the result and status flags based on `A`, `B`, and `ALU_sel`.

2. **Sequential Output Block**  
   Registers outputs synchronously on the rising edge of `clk` or clears them during an active-high `reset`.

   ### Additional Features
      - **Reset Type:** Active-high synchronous reset  
      - **Clock Edge:** Positive-edge triggered  
      - **Output Update:** All outputs are updated at `posedge clk`, unless `reset` is high

<img width="797" height="332" alt="image" src="https://github.com/user-attachments/assets/8e9d8ee6-0cc8-4478-81cd-eb4200baa78e" />


## 📁 Project Structure
```
.
├── alu.v # ALU RTL module
├── alu_tb.sv # SystemVerilog testbench (WIP)
├── alu.vcd # Sample VCD file for GTKWave
├── synth.ys # Yosys synthesis script
├── alu_synth.v # Netlist design generated by yosys
├── alu_netlist.dot # Netlist visualization for GraphViz
└── README.md # This file
```

## 🔧 RTL Design

- ✅ **Parameterizable** input/output width (default: 8 bits)
- ✅ **Synchronous operation** (clock + active-high reset)
- ✅ **Supported ALU Operations:**

| Op Code | Operation | Description                      |
|--------:|-----------|----------------------------------|
| `0000`  | ADD       | A + B (signed/unsigned)          |
| `0001`  | SUB       | A − B (signed/unsigned)          |
| `0010`  | AND       | Bitwise AND                      |
| `0011`  | OR        | Bitwise OR                       |
| `0100`  | XOR       | Bitwise XOR                      |
| `0101`  | SLL       | Logical left shift               |
| `0110`  | SRL       | Logical right shift              |
| `0111`  | SRA       | Arithmetic right shift           |
| `1000`  | SLT       | Set Less Than (signed comparison)|

- ✅ **Status Flags:**
  - `Zero`: Result is zero  
  - `Carry`: Carry-out or borrow  
  - `Negative`: MSB of result  
  - `Overflow`: Signed overflow detection


<img width="792" height="817" alt="image" src="https://github.com/user-attachments/assets/777aa69a-a245-44c4-b12e-456461867d4b" />

---

## 🧪 Simulation using Icarus Verilog + GTKWave

- Testbench written in SystemVerilog
- Uses `$dumpfile`, `$dumpvars` for waveform output
- Simulated using:

```bash
iverilog -o alu_out alu.v alu_tb.sv
vvp alu_out
gtkwave alu.vcd
```
  Testbench Preview:
  -
  <img width="693" height="794" alt="image" src="https://github.com/user-attachments/assets/df7e8c5b-dee1-49ec-9006-2da687bdabf0" />

  Running the testbench
  -
  <img width="1300" height="542" alt="image" src="https://github.com/user-attachments/assets/0e6b27d3-fcd7-4a53-8891-e884f2eed392" />

  Waveform
  -
  <img width="1692" height="709" alt="image" src="https://github.com/user-attachments/assets/75f93e80-b394-4315-b1df-a7d095b4b1ec" />



## ⚙️ Synthesis using Yosys

#### Uses `sky130_fd_sc_hd__tt_025C_1v80.lib` standard cell library

  ### 1.  Install Yosys
  

    https://yosyshq.net/yosys/

  ### 2. Check if yosys is installed
  
  <img width="1310" height="832" alt="yosys_1" src="https://github.com/user-attachments/assets/0082d845-495f-4f10-9d7c-b2b071a672d4" />
  
  ### 3. Write Synthesis Script (`synth.ys`) or directly run the following commands

```yosys
# Load the Liberty file with area info
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

# Read your Verilog RTL
read_verilog alu.v

# Run synthesis
synth -top ALU

# Map to standard cells from Liberty
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

# Generate area/timing report
stat -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

#Write netlist to alu_synth.v
write_verilog alu_synth.v

#Show netlist (.dot file) using Graphviz
show -format dot -prefix alu_netlist
```

## 🏁 Gate-Level Simulation (GLS)

Simulate the synthesized netlist using original testbench:

iverilog -o alu_gls alu_synth.v alu_tb.sv
vvp alu_gls

    Use GTKWave to view post-synthesis waveform and confirm logic equivalence

## 📐 Area Estimation

`Total cells used`: 258

`Synthesized area`: 1669.10 µm²

`Technology`: Sky130 standard cell library

`Includes` flip-flops, MUXes, logic gates

## 📷 Netlist Visualization (DOT)

Yosys command:
```
show -format dot -prefix alu_netlist
```
Render using Graphviz:
```
dot -Tpng alu_netlist.dot -o alu_netlist.png
```
  Netlist
  -
  <img width="1010" height="1040" alt="image" src="https://github.com/user-attachments/assets/67072648-2f88-4850-a8f3-e09cd7e26b12" />

## 🧠 Testbench and Verification Strategy

    Random stimulus generation (planned)

    Edge case testing: overflow, SLT, carry

    Functional coverage (WIP)

    Formal assertions (future work)

## 📎 References and Resources

    Sky130 PDK

    Yosys HQ

    GTKWave

    Graphviz

## ✍️ Author

Abhimanyu Kumar
3rd Year ENC Student | Thapar Institute
Aspiring VLSI Engineer | Passion for RTL Design, Computer Architecture, SoCs

## 📬 Contact



